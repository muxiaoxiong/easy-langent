#  第六章 LangGraph基础：有状态工作流与核心概念实操

## 前言
各位同学，上一章我们掌握了LangChain的基础工作流构建，当面对更复杂的任务——比如需要循环迭代、动态分支、状态回溯的场景时，LangChain的链式流就显得有些局限了。
这一章我们聚焦LangGraph，它作为LangChain生态中负责复杂工作流编排的核心框架，1.0版本后更是强化了生产级特性，能帮我们实现有状态、可追溯、高灵活度的工作流。

接下来我们从理念到实操，逐步吃透LangGraph。

> LangGraph 是 LangChain 团队在 2024 年推出的核心框架，到了 2025 年，它已经成为构建 Production-Ready（生产级）Agent 的行业标准。

## 6.1 LangGraph核心设计理念：图结构驱动的工作流建模
在正式上手前，我们先搞懂LangGraph的设计初衷。大家可以把工作流想象成一张“任务地图”，传统链式流是“单一路线”，而LangGraph的图结构是“多节点、多路径”的地图，能应对更复杂的路况。

### 6.1.1 为什么需要图结构工作流？——解决复杂任务的流程可控性问题
在AI应用开发中，我们常面临超越线性流程的复杂任务。比如一个智能客服系统，需要先识别用户意图，再根据意图分发到技术支持、订单咨询等不同节点，若回答不达标还需回退重生成——这种包含分支、循环的场景，传统线性链式工作流（如LangChain早期Chain）难以高效支撑。

线性流程的核心痛点是“刚性”：一旦定义好步骤顺序，难以动态调整，且无法很好地管理跨步骤的数据共享和状态回溯。而图结构工作流通过“节点”封装功能、“边”定义路径、“状态”共享数据，能精准解决这些问题，让复杂流程的每一步都可控制、可追溯。

langGraph通过对智能体工作流进行图结构建模，它具有以下几个核心价值：

- **显式控制：**通过流程图明确指定执行路径，避免智能体在复杂任务中"乱跑"
- **可预测性：**结果更稳定，行为更可预测
- **精细调控：**明确规定下一步走哪个节点、何时调用工具、何时循环或终止

![6-1](..\src\img\6-1.png)

### 6.1.2 与LangChain工作流的差异与互补性
很多同学会问：有了LangChain，为什么还要用LangGraph？其实两者不是替代关系，而是互补关系，LangChain 1.0的Agent能力甚至是基于LangGraph运行时构建的。

#### 6.1.2.1 对比维度：流程灵活性、状态管理、循环与分支支持
我们从三个核心维度对比：流程灵活性上，LangChain链式流适合线性、固定步骤的任务，抽象层级高，上手快；LangGraph图结构流支持分支、循环、并行，灵活性拉满，但需要手动定义节点和边。

状态管理上，LangChain的状态分散在各个Chain中，需手动传递上下文；LangGraph有统一的状态对象，支持字段级合并策略（如追加、覆盖），且内置持久化能力，无需额外开发。

循环与分支支持上，LangChain需通过条件判断代码实现简单分支，循环需手动控制次数；LangGraph通过条件边和循环边原生支持，且能通过终止条件避免无限循环，更贴合复杂场景。

#### 6.1.2.2 适用场景划分：何时选LangChain链式流，何时选LangGraph图结构流
实际开发中，我们可以这样选择：快速搭建原型、任务流程固定（如“文本生成→格式转换”），选LangChain链式流，效率更高；任务流程复杂（有分支、循环、并行）、需要状态追溯、追求生产级稳定性（如多Agent协作、长时任务），选LangGraph图结构流。

## 6.2 LangGraph三大核心组件深度解析
LangGraph的核心是“图”，而构成图的三大组件的是：状态（State）、节点（Nodes）、边（Edges）。这三者就像积木，组合起来就能搭建出任意复杂的工作流。

### 6.2.1 状态（State）：工作流的“全局账本”
在 LangGraph 中，状态（State）是整个工作流的核心，也是所有节点协作的基础。

如果把 LangGraph 的工作流类比成一个“多人协作的任务系统”，那么状态就相当于一份所有人共享的「工作记录本」：

每个节点不直接把结果传给下一个节点,而是把自己的执行结果写入状态,后续节点再从状态中读取所需信息继续执行

也就是说：

节点之间并不相互“对话”，它们只通过状态“沟通”。

这种设计，使得工作流的执行过程清晰、可控、可追踪，也是 LangGraph 能够支持复杂分支、循环和中断恢复的根本原因。

#### 6.2.1.1 核心本质：共享数据载体与状态快照

状态的核心本质有两个：一是共享数据载体，所有节点都能访问和修改状态中的字段，确保数据一致性；二是状态快照，配合Checkpointer，每一步状态变化都会被记录，支持回溯和断点续跑。比如长时任务执行到一半服务器重启，恢复后能从上次的状态继续，无需重新执行。

#### 6.2.1.2 状态传递机制：节点间的数据共享与更新逻辑
状态传递的逻辑很简单：工作流启动时初始化状态，每个节点执行时接收当前状态，处理后返回需要更新的字段，LangGraph会根据合并策略更新全局状态，再传递给下一个节点。

这里要注意：节点返回的字典只需包含要更新的字段，无需返回完整状态。比如节点只更新progress字段，就返回{"progress": 1}，LangGraph会自动合并到全局状态中。

### 6.2.2 节点（Nodes）：工作流的“功能执行单元”
节点是工作流的“功能执行单元”，相当于图结构中的“站点”，每个节点封装一段具体逻辑，接收状态、执行任务、返回新状态。

#### 6.2.2.1 核心作用：接收状态、执行逻辑、输出新状态

节点的核心作用有三个：一是接收全局状态，提取所需字段作为输入；二是执行具体逻辑，比如调用LLM、工具、数据处理；三是将执行结果封装成状态更新字典，返回给LangGraph。

需要注意：节点必须是无副作用的纯函数，逻辑只依赖输入的状态，不依赖外部变量，这样才能保证状态的可追溯性和可复现性。

#### 6.2.2.2 节点类型：LLM调用节点、工具调用节点、数据处理节点

根据功能不同，节点主要分为三类：

LLM调用节点：负责调用大模型生成内容，比如根据用户查询生成回答，核心是将状态中的字段（如user_query）传入模型，将生成结果存入状态。

工具调用节点：负责调用外部工具，比如Elasticsearch检索、天气API查询，核心是提取状态中的参数，调用工具后将结果更新到状态。

数据处理节点：负责数据转换、校验、格式处理，比如将生成的回答格式化、校验结果是否合格，核心是对状态中的数据进行加工，返回处理后的值。

### 6.2.3 边（Edges）：工作流的“路径导航员”
边是连接节点的“路径”，定义了节点间的跳转规则，决定了工作流的执行顺序。LangGraph 1.0+支持两种核心边类型：固定边和条件边。

#### 6.2.3.1 核心作用：定义节点间的跳转规则

边的核心作用就是“导航”，告诉工作流“当前节点执行完后，下一步该去哪个节点”。没有边的连接，节点就是孤立的，无法形成完整工作流。简单来说，边就是工作流的“执行路线图”。

#### 6.2.3.2 两种核心边类型：固定边与条件边

固定边是最简单的边类型，指定“从A节点到B节点”的固定跳转，无论状态如何变化，执行完A后必然执行B，适合线性流程。

条件边是动态边，根据当前状态判断跳转方向，支持多分支跳转，适合需要动态决策的场景。比如根据用户需求意图，判断是走“总结”分支还是“改写”分支。

此外，LangGraph还支持循环边，本质是条件边的一种特殊形式，通过判断状态是否满足终止条件，决定是回溯到前序节点继续执行，还是进入下一个节点。

## 6.3 LangGraph运行机制：基于超步骤的消息传递
了解了三大组件后，我们再来看LangGraph的运行机制。LangGraph采用“超步骤（super-step）”机制管理执行流程，确保节点执行的有序性和状态的一致性。

### 6.3.1 核心概念：超步骤（super-step）与节点活跃状态

超步骤是LangGraph执行工作流的基本单位，可理解为“一轮并行任务执行周期”。每个超步骤内，框架会完成三件事：

1. 激活节点：所有收到消息（状态更新）的节点会从“休眠状态”变为“活跃状态”；2. 执行节点：所有活跃节点并行执行逻辑，生成新的状态片段；3. 传递消息：将新的状态片段作为消息，传递给下一个节点，同时节点回归休眠状态。

这种机制让LangGraph天然支持并行执行——同一超步骤内的活跃节点可同时运行，提升流程效率；同时通过消息传递实现节点间的协同，确保状态一致性。

### 6.3.2 完整执行流程：启动→节点激活→逻辑执行→状态传递→投票停止→终止

一个完整的LangGraph工作流执行流程可分为六个阶段：

1. 启动：调用graph.invoke()方法传入初始状态，框架将初始状态作为消息，发送给入口节点，入口节点被激活，进入第一个超步骤。
2. 节点激活：入口节点接收消息后变为活跃状态，其他节点保持休眠。
3. 逻辑执行：活跃节点执行自身逻辑，读取初始状态，生成更新后的状态片段。
4. 状态传递：框架合并状态片段为新的全局状态，根据边的规则，将新状态作为消息传递给下一个（或多个）节点，激活对应节点。
5. 投票停止：每个超步骤结束后，所有节点进行“停止投票”——若没有节点被激活，且无待传递的消息，投票通过，流程准备终止；否则进入下一个超步骤，重复2-4阶段。
6. 终止：投票通过后，框架返回最终的全局状态，工作流执行结束。

补充：若工作流中设置了END节点，当节点跳转到END时，会直接触发终止流程，无需等待投票。