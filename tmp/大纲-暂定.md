# 课程目标
掌握LangChain与LangGraph框架的核心用法，理解两大框架的技术优势，具备独立设计并实现智能体的能力，能够结合实际场景构建可落地的AI应用系统。

# 核心逻辑
从基础认知到实操应用，从单框架掌握到多框架融合，从技术要点拆解到综合项目实战，层层递进构建知识体系，最终实现“理论+实践”的闭环学习。

# 第1章 LangChain与LangGraph框架认知

1.1 为什么需要LangChain和LangGraph
1.2 LangChain与LangGraph分别是什么？
  1.2.1 LangChain：大模型应用的“基础设施工具箱”
  1.2.2 LangGraph：复杂应用的“架构设计框架”
  1.2.3两个框架的核心关系
1.3 实操环节：搭建开发环境
  1.3.1 环境要求
  1.3.2 具体步骤（Windows/Mac通用）
  1.3.3 常见错误解决
1.4 上手体验：两个框架的“Hello World”案例
  1.4.1 LangChain案例：简单文本生成
  1.4.2 LangGraph案例：基础工作流执行
1.5 本章小节
1.6 本章练习    

# 第2章 LangChain核心组件实操

2.1 模型调用（ChatOpenAI）：统一接口适配不同大模型
  2.1.1LLM与ChatModel的区别
  2.1.2 实操案例1：统一接口调用不同模型
2.2提示词模板（PromptTemplate）：让提示更规范、可复用
  2.2.1提示词模板基础用法：标准化提示与动态参数
  2.2.2提示词模板进阶用法：少样本提示模板
  2.2.3 工程化实践：少样本提示模板的高效管理
    2.2.3.1 核心痛点与解决方案
    2.2.3.2 动态示例选择：ExampleSelector的使用
    2.2.3.3 工程化最佳实践总结
2.3 输出解析（OutputParser）：让输出更可控
  2.3.1 为什么需要OutputParser？
  2.3.2 核心工作原理
  2.3.3 常见OutputParser类型及实践案例
    2.3.3.1 案例1：逗号分隔列表解析器（CommaSeparatedListOutputParser）
    2.3.3.2 案例2：JSON解析器（JsonOutputParser）
    2.3.3.3 案例3：自定义解析器（基础实现）
  2.3.4 OutputParser工程化使用要点
2.4 输入控制层核心总结
2.5 本章小节
2.6 本章练习

# 第3章 LangChain进阶组件实操

3.1 状态管理层（Memory）：让模型拥有记忆能力
  3.1.1 对话记忆的本质与作用
    3.1.1.1 核心本质
    3.1.1.2 核心作用
  3.1.2 三种基础Memory组件实操
    3.1.2.1 全量记忆
    3.1.2.2 窗口记忆
    3.1.2.3 摘要记忆
    3.1.2.4 三种Memory怎么选？
    3.1.2.5 工程建议
    3.1.2.6 深入理解：记忆是怎么注入到对话里的？
3.2外部行动层（Tool）：让AI能“动手”解决问题
  3.2.1 先搞懂：工具调用的核心逻辑
    3.2.1.1 三个关键组件
    3.2.1.2 学习案例：查天气
  3.2.2 高级技巧：自定义工具（@tool装饰器）
    3.2.2.1 自定义工具的核心要求
    3.2.2.2 学习案例:温度单位转换
  3.2.3 其他常用内置工具
    3.2.3.1 学习案例：创建文件
3.3. 综合实践：把Memory和Tool组合起来
  3.3.1 实践1：带记忆的对话机器人
  3.3.2 实践2：带记忆的文件夹操作助手
  3.3.3 组合实践总结
3.4 本章小结
3.5 本章练习


# 第4章 LangChain应用级系统设计与RAG实践

4.1 链式工作流设计：复杂任务的拆解与流转
  4.1.1 链式工作流核心认知
    4.1.1.1 为什么需要结构化链式工作流？
    4.1.1.2 常见链式工作流类型与适用场景
  4.1.2 基于 RunnableSequence / `|` 运算符
    4.1.2.1 核心原理：Runnables 的线性流转逻辑
    4.1.2.2 基础实践：单输入输出线性流转
    4.1.2.3 进阶实践：多输入多输出复杂线性任务
4.2 路由链设计与异常处理：动态任务分发与系统稳健性
  4.2.1 RouterChain（路由链）核心原理
    4.2.1.1 基于条件判断的动态任务分发机制
    4.2.1.2 关键组件：RouteSelector（路由选择器）工作机制
  4.2.2 RouterChain 实践案例
    4.2.2.1 多场景需求的动态路由匹配（如客服咨询分类处理）
  4.2.3 链式工作流的错误处理机制
    4.2.3.1 常见错误类型与触发场景
    4.2.3.2 工程化解决方案：重试机制、异常捕获与分支降级
4.3 RAG 核心原理与应用价值
  4.3.1 大模型原生痛点：知识滞后与事实性错误的根源
  4.3.2 RAG 核心逻辑：检索增强的本质是“知识补充”与“事实校验”
  4.3.3 RAG 的核心价值：提升应用准确性、拓展知识边界、降低微调成本
  4.3.4 RAG 适用场景与不适用场景辨析
4.4 RAG 系统构建全流程实操
  4.4.1 文档加载（Document Loading）
    4.4.1.1 常见文档格式适配（PDF、Word、Markdown、TXT）
    4.4.1.2 实操案例：多格式文档的统一加载与解析
  4.4.2 文本分割（Text Splitting）策略
    4.4.2.1 分割核心原则：语义完整性与检索相关性平衡
    4.4.2.2 常见分割算法：字符分割、递归字符分割、语义分割
    4.4.2.3 实操案例：不同场景下的分割参数调优
  4.4.3 向量存储（VectorStore）选型与使用
    4.4.3.1 向量存储核心作用：高效相似性检索的基础
    4.4.3.2 主流向量存储对比：Chroma、FAISS、Pinecone 的特点与选型建议
    4.4.3.3 实操案例：文本向量化与向量库构建、增删改查
  4.4.4 检索器（Retriever）配置
    4.4.4.1 检索器核心作用：连接向量存储与大模型的桥梁
    4.4.4.2 基础检索策略：相似性检索、MMR 检索（最大边际相关性）
    4.4.4.3 实操案例：检索器参数配置与检索效果验证
4.5 LangChain RAG 综合实践：文档问答机器人构建
  4.5.1 项目需求拆解与技术方案设计
  4.5.2 分步实现：从文档加载到问答交互的全流程搭建
  4.5.3 优化实践：提升检索匹配精度的核心方法
    4.5.3.1 多轮检索：基于上下文的迭代式检索优化
    4.5.3.2 相关性排序：检索结果的重排策略与实现
    4.5.3.3 实操案例：优化前后问答效果对比与验证
4.6 RAG 系统的评估与调优方法
  4.6.1 评估核心指标：相关性、准确性、响应速度
  4.6.2 评估方法：人工评估与自动化评估工具
  4.6.3 调优方向：分割策略、向量模型、检索参数优化
  4.6.4 工程化调优实践总结
4.7 本章小结
  4.7.1 核心知识点回顾（链式工作流、RAG 全流程）
  4.7.2 技术落地关键要点总结
4.8 本章练习
  4.8.1 基础练习：基于 SequentialChain 实现多步骤文本处理任务
  4.8.2 进阶练习：构建支持 PDF 文档的 RAG 问答机器人并完成调优
  4.8.3 拓展练习：为 RAG 系统添加错误处理与分支降级机制

# 第5章 课程中期综合实践：智能体应用设计与实现

5.1 中期综合实践项目说明
  5.1.1 核心目标：构建可运行的智能体应用
  5.1.2 价值目标：解决一个相对完整、真实问题场景
5.2 功能与技术要求（完成参考线）
  5.2.1 模型与提示层
  5.2.2 链式工作流
  5.2.3 状态与行动能力（核心能力）
  5.2.4 输出可控性（基础要求）
5.3 项目选题方向（建议参考）
  5.3.1 智能问答类
    5.3.1.1 基于文档的问答机器人（RAG）
 5.3.1.2 支持多轮上下文理解与追问的问答助手
  5.3.2 助手工具类
    5.3.2.1 文本处理助手（总结/改写/分类）
    5.3.2.2 文件操作或数据整理助手
  5.3.3 业务流程类
    5.3.3.1 简化版客服问答系统
    5.3.3.2 意图识别 + 不同处理链路
  5.3.4 自定义选题
5.4 项目设计与实现指导
  5.4.1 需求拆解方法：从用户问题到子任务划分
  5.4.2 常见误区提醒：避开这些“坑”
5.5 项目成果交付建议
  5.5.1 代码成果
  5.5.2 项目说明文档（README）
5.6 自我检查清单
5.7 本章总结

# 第6章 LangGraph基础：有状态工作流与核心概念

6.1 LangGraph图结构驱动的工作流
  6.1.1 为什么需要图结构工作流？
  6.1.2 与LangChain工作流的差异与互补性
6.2 LangGraph核心概念：图状态、点、边
  6.2.1 状态（State）：工作流的“共享黑板”
    6.2.1.1 状态传递机制
  6.2.2 节点（Nodes）：工作流的“功能小工人”
    6.2.2.1 核心作用：接收状态、执行逻辑、输出新状态
    6.2.2.2 节点类型：LLM调用节点、工具调用节点、数据处理节点
    6.2.2.3节点实现规范：函数定义格式与状态交互方式
  6.2.3 边（Edges）：工作流的“路径导航员”
    6.2.3.1 核心作用：定义节点间的跳转规则
    6.2.3.2 核心边类型与实践
  6.2.4总结
6.3 LangGraph运行机制：基于超步骤的消息传递
  6.3.1 超步骤（Super-step）与节点活跃状态
  6.3.2 LangGraph 工作流执行全过程
  6.3.3 并行与顺序执行
6.4 综合实操
  6.4.1 实操准备：LangGraph环境确认与核心API导入
  6.4.2 案例1：简单线性工作流——文本处理全流程串联
    6.4.2.1 案例设计思路
  6.4.3 案例2：分支工作流——带结果校验的动态文本处理
    6.4.2.1 案例设计思路
  6.4.4 案例3：循环工作流——人机互式文本优化
    6.4.4.1 案例设计思路
6.5 本章小结
  6.5.1 核心知识梳理
  6.5.2 实践落地建议
  6.5.3本章练习

# 第7章 LangGraph进阶：多智能体协作与复杂流程管控
7.1 多智能体系统（Multi-Agent Systems）核心设计
  7.1.1 为什么需要多智能体协作？
    7.1.1.1 解决单一 LLM “长指令疲劳”与上下文污染
    7.1.1.2 模块化开发：分而治之的工程学思想
  7.1.2 多智能体常见架构模式
    7.1.2.1 中心化协作（Supervisor）：基于路由的“主管-员工”模式
    7.1.2.2 链式协作（Sequence）：有序的任务接力
    7.1.2.3 去中心化协作（Peer-to-peer）：基于状态触发的自主协同
  7.1.3 智能体间的通信机制
    7.1.3.1 基于全局状态（State）的消息共享
    7.1.3.2 角色定义与 System Prompt 的差异化设计
7.2 复杂流程的高级管控技术
  7.2.1 子图（Subgraphs）机制：复杂系统的模块化拆解
    7.2.1.1 什么是子图？实现逻辑隔离与复用
    7.2.1.2 实操案例：在主流程中嵌入一个独立的“文档校验”子图
  7.2.2 并行任务处理（Parallelization）
    7.2.2.1 扇出与扇入：同时调用多个智能体并汇总结果
    7.2.2.2 实现技巧：如何处理并发状态的合并冲突
  7.2.3 循环逻辑与迭代优化
    7.2.3.1 任务重试机制：当输出不达标时的自我修正循环
    7.2.3.2 限制循环次数：防止系统陷入“无限递归”的死循环
7.3 人机协作机制（Human-in-the-loop）
  7.3.1 检查点（Checkpoints）与状态持久化
    7.3.1.1 核心原理：如何保存与恢复工作流进度
    7.3.1.2 MemorySaver 的配置与使用
  7.3.2 中断机制（Interrupts）实战
    7.3.2.1 在执行前中断：关键操作（如转账、发邮件）的人工授权
    7.3.2.2 案例演示：设计一个“需要用户审批”的节点
  7.3.3 动态状态编辑（State Management）
    7.3.3.1 手动修正：人工干预并修改智能体的中间输出
    7.3.3.2 回退与跳转：将工作流重置到之前的任意节点   
7.4 可视化调试与系统追踪
  7.4.1 图结构可视化工具
    7.4.1.1 静态可视化：生成 Mermaid 图表与图片
    7.4.1.2 动态调试：利用 LangGraph Studio（或同类工具）观察状态流转
  7.4.2 集成 LangSmith 进行深度追踪
    7.4.2.1 Trace 追踪：准确定位哪一个智能体节点出现了逻辑偏差
    7.4.2.2 性能与成本监控：分析各节点的 Token 消耗与延迟
    7.4.2.3 单元测试：基于追踪数据构建回归测试集
7.5 综合实践：多智能体小说创作助手
  7.5.1 项目需求与角色定义
    7.5.1.1 世界观设定 Agent：负责小说核心设定的搭建与一致性校验
    7.5.1.2 情节设计 Agent：负责小说章节情节的规划与撰写
    7.5.1.3 人设与风格 Agent：负责人物形象塑造与语言风格统一
    7.5.1.4 协调 Agent（Supervisor）：负责任务分发、结果审核与冲突协调
  7.5.2 全流程开发实操
7.6 本章小结
  7.6.1 核心知识回顾：多智能体、人机协作、状态持久化
  7.6.2 从“实验 Demo”到“生产级应用”的转型关键点
7.7 本章练习
  7.7.1 基础练习：手动实现一个带有 interrupt_before 功能的简单流程。
  7.7.2 进阶练习：构建一个“代码生成-代码自检-人工修改”的循环工作流。
  7.7.3 拓展练习：尝试将第五章的单智能体项目重构为基于“子图”的多智能体协作模式。


# 第8章 Skills在lang系列框架中的应用

## 核心目标

提炼智能体构建的通用方法论，明确框架选型依据，掌握智能体的评估与优化策略。

## 主要内容

- 智能体核心架构：感知-决策-执行三层架构设计、核心模块（规划器、记忆、工具集）职责划分
- 框架选型原则：何时选择LangChain（简单任务、快速原型）、何时选择LangGraph（复杂流程、多智能体）、两者融合使用场景
- 任务规划与拆解：复杂任务的结构化拆解方法、目标导向的路径规划、动态规划调整策略
- 智能体评估指标：准确性、效率（响应速度、token消耗）、鲁棒性（边缘情况处理）、用户体验
- 优化策略：提示词工程优化、工具选择优化、记忆机制优化、错误恢复机制完善

## 学习产出

能够运用智能体设计原则进行架构规划，合理选择框架，具备智能体的评估与优化能力。

# 第9章 综合实战：构建“谁是卧底”游戏智能体引擎

## 核心目标

整合前6章知识，完成从需求分析到部署的全流程智能体开发，总结两大框架的核心价值与应用经验。

## 主要内容

- 项目需求分析：确定智能体应用场景（如学术研究助手、智能客服路由系统）、明确功能目标与评估标准
- 系统架构设计：框架选型（LangChain+LangGraph融合）、模块划分、智能体角色与协作逻辑设计
- 全流程开发实现：        
  - 基础组件开发（提示模板、工具集、记忆模块）
  - 核心流程构建（LangGraph工作流设计、状态管理、条件分支）
  - 多智能体协作实现（角色分配、通信机制）
  - 错误处理与优化（重试机制、边缘情况适配）
- 系统测试与调优：功能测试、性能评估、基于LangSmith的调试与优化
- 部署与迭代：基础部署方案（LangServe集成）、后续迭代方向规划
- 课程总结：两大框架核心优势回顾、智能体开发关键经验提炼、行业应用趋势与进阶学习方向

## 学习产出

独立完成一个可落地的智能体系统开发，形成完整的项目开发文档，系统掌握LangChain与LangGraph的融合应用能力。


LangSmith LangServe 